#version 460 core

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

struct Particle {
    vec3 position;
    float density;
    vec3 velocity;
    float pressure;
};

layout(std430, binding = 0) restrict buffer Particles {
    Particle particles[];
};

layout(std430, binding = 1) restrict readonly buffer Counts {
    uint counts[];
};

layout(std430, binding = 2) restrict readonly buffer Offsets {
    uint offsets[];
};

// layout(binding = 3) uniform sampler3D distanceField;
uniform float size;
uniform float binSize;
uniform int gridRes;
uniform float dt;
uniform int numParticles;
uniform vec3 gravity;
uniform float particleMass;
uniform float kernelRadius;
uniform float viscosityCoefficient;
uniform float viscosityWeight;
uniform float pressureWeight;

// neighborhood coordinate offsets
const ivec3 NEIGHBORHOOD[27] = {
    ivec3(-1, -1, -1), ivec3(0, -1, -1), ivec3(1, -1, -1),
    ivec3(-1, -1,  0), ivec3(0, -1,  0), ivec3(1, -1,  0),
    ivec3(-1, -1,  1), ivec3(0, -1,  1), ivec3(1, -1,  1),
    ivec3(-1,  0, -1), ivec3(0,  0, -1), ivec3(1,  0, -1),
    ivec3(-1,  0,  0), ivec3(0,  0,  0), ivec3(1,  0,  0),
    ivec3(-1,  0,  1), ivec3(0,  0,  1), ivec3(1,  0,  1),
    ivec3(-1,  1, -1), ivec3(0,  1, -1), ivec3(1,  1, -1),
    ivec3(-1,  1,  0), ivec3(0,  1,  0), ivec3(1,  1,  0),
    ivec3(-1,  1,  1), ivec3(0,  1,  1), ivec3(1,  1,  1)
};

// Equation (8) from Harada
vec3 Wpress(vec3 r, float d) {
    // const float weight = 45.0 / (3.14 * pow(kernelRadius, 6));
    return pow(kernelRadius - d, 3) * (r / d) * pressureWeight;
}

// Equation (9) from Harada
float Wvis(float r) {
    // const float weight = 45.0 / (3.14 * pow(kernelRadius, 6));
    return (kernelRadius - r) * viscosityWeight;
}

void main() {
    const uint particleID = gl_GlobalInvocationID.x;
    if (particleID >= numParticles) {
        return;
    }

    Particle p = particles[particleID];
    const ivec3 coord = ivec3(p.position / binSize);
    
    vec3 pressureForce = vec3(0);
    vec3 viscosityForce = vec3(0);

    // search the particles of each neighboring bin
    #pragma unroll 1
    for (uint binIndex = 0; binIndex < 27; binIndex++) {
        const ivec3 nc = coord + NEIGHBORHOOD[binIndex];

        // don't go out of bounds
        if (any(lessThan(nc, ivec3(0))) || any(greaterThanEqual(nc, ivec3(gridRes)))) {
            continue;
        }

        const uint index = nc.z * gridRes * gridRes + nc.y * gridRes + nc.z;
        const uint count = counts[index];
        const uint offset = offsets[index];

        // search the particles of this bin
        for (uint localIndex = 0; localIndex < count; localIndex++) {
            const uint otherParticleID = offset + localIndex; 
            Particle other = particles[otherParticleID];
            if (particleID == otherParticleID) {
                continue;
            }
            
            // find the distance, ignore if too far
            const vec3 r = p.position - other.position;
            const float dist = length(r);
            if (dist >= kernelRadius) {
                continue;
            }

            // if not self, calculate pressure weight
            vec3 mPressureWeight = vec3(0);
            if (dist > 0) {
                mPressureWeight = Wpress(r, dist);
            }

            // Equation (6) from Harada
            const float pressure = (p.pressure + other.pressure) / (2.0 * other.density);
            if (pressure > 0) {
                pressureForce += particleMass * pressure * mPressureWeight;
            }
        
            // Equation (7) from Harada
            const vec3 velocityDiff = other.velocity - p.velocity;
            viscosityForce += particleMass * (velocityDiff / other.density) * Wvis(dist);
        }
    }

    // find distance to nearest wall
    // const vec4 interpolatedDistance = texture(distanceField, p.position / size);
    // const vec3 normal = interpolatedDistance.xyz;
    // const float dist = interpolatedDistance.a;
    // compute pressure from wall
    vec3 wallForce = vec3(0);
    // const float d = kernelRadius / 4.0; // ?
    // if (dist <= d) {
    //     // Equation (11) from Harada
    //     wallForce = particleMass * (((d - abs(dist)) * normal) / (d * dt * dt));
    // }

    // Sum of Equations (6) and (7) and external forces from Herada
    const vec3 externalForces = gravity * p.density + wallForce;
    viscosityForce *= viscosityCoefficient;
    const vec3 force = viscosityForce - pressureForce + externalForces;

    // find accelaration and integrate
    const vec3 acceleration = force / (p.density + 1e-16);
    vec3 vel = p.velocity + acceleration * dt;
    vec3 pos = p.position + vel * dt;
    const float wallDamping = 0.5;

    if (pos.x < 0) {
        vel.x *= -wallDamping;
        pos.x = 0;
    } else if (pos.x > size) {
        vel.x *= -wallDamping;
        pos.x = size;
    }

    if (pos.y < 0) {
        vel.y *= -wallDamping;
        pos.y = 0;
    } else if (pos.y > size) {
        vel.y *= -wallDamping;
        pos.y = size;
    }

    if (pos.z < 0) {
        vel.z *= -wallDamping;
        pos.z = 0;
    } else if (pos.z > size) {
        vel.z *= -wallDamping;
        pos.z = size;
    }

    p.velocity = vel;
    p.position = pos;
    particles[particleID] = p;
}
