#version 460 core
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

struct Particle {
    vec3 position;
    float density;
    vec3 velocity;
    float pressure;
};

layout(std430, binding = 0) restrict buffer Particles {
    Particle particles[];
};

layout(std430, binding = 1) restrict readonly buffer Counts {
    uint counts[];
};

layout(std430, binding = 2) restrict readonly buffer Offsets {
    uint offsets[];
};

layout(binding = 3) uniform sampler3D distanceField;
layout(binding = 4) uniform sampler1D wallWeight;
uniform float size;
uniform float binSize;
uniform int gridRes;
uniform int numParticles;
uniform float particleMass;
uniform float kernelRadius;
uniform float kernelWeight;
uniform float stiffness;
uniform float restDensity;
uniform float restPressure;

// neighborhood coordinate offsets
const ivec3 NEIGHBORHOOD[27] = {
    ivec3(-1, -1, -1), ivec3(0, -1, -1), ivec3(1, -1, -1),
    ivec3(-1, -1,  0), ivec3(0, -1,  0), ivec3(1, -1,  0),
    ivec3(-1, -1,  1), ivec3(0, -1,  1), ivec3(1, -1,  1),
    ivec3(-1,  0, -1), ivec3(0,  0, -1), ivec3(1,  0, -1),
    ivec3(-1,  0,  0), ivec3(0,  0,  0), ivec3(1,  0,  0),
    ivec3(-1,  0,  1), ivec3(0,  0,  1), ivec3(1,  0,  1),
    ivec3(-1,  1, -1), ivec3(0,  1, -1), ivec3(1,  1, -1),
    ivec3(-1,  1,  0), ivec3(0,  1,  0), ivec3(1,  1,  0),
    ivec3(-1,  1,  1), ivec3(0,  1,  1), ivec3(1,  1,  1)
};

// Equation (10) from Harada
float W(float r) {
    return pow(kernelRadius * kernelRadius - r * r, 3) * kernelWeight;
}

void main() {
    const uint particleID = gl_GlobalInvocationID.x;
    if (particleID >= numParticles) {
        return;
    }

    Particle p = particles[particleID];
    const ivec3 coord = ivec3(p.position / binSize);

    float density = particleMass * pow(kernelRadius * kernelRadius, 3) * kernelWeight;

    // search the particles of each neighboring bin
    #pragma unroll 1
    for (uint binIndex = 0; binIndex < 27; binIndex++) {
        const ivec3 nc = coord + NEIGHBORHOOD[binIndex];

        // don't go out of bounds
        if (any(lessThan(nc, ivec3(0))) || any(greaterThanEqual(nc, ivec3(gridRes)))) {
            continue;
        }

        const uint index = nc.z * gridRes * gridRes + nc.y * gridRes + nc.z;
        const uint count = counts[index];
        const uint offset = offsets[index];

        // search the particles of this bin
        for (uint localIndex = 0; localIndex < count; localIndex++) {
            const uint otherParticleID = offset + localIndex;
            if (particleID == otherParticleID) {
                continue;
            }

            // find the distance, ignore if too far
            const vec3 r = p.position - particles[otherParticleID].position;
            const float dist = length(r);
            if (dist >= kernelRadius) {
                continue;
            }

            // Equation (4) from Harada
            density += particleMass * W(dist);
        }
    }

    // check distance to nearest wall
    const float dist = texture(distanceField, p.position / size).a;
    if (dist <= kernelRadius) {
        density += texture(wallWeight, dist / kernelRadius).x;
    }

    p.density = density;

    // Equation (5) from Harada
    p.pressure = restPressure + stiffness * (density - restDensity);

    particles[particleID] = p;
}
