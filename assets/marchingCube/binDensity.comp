#version 460 core

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

const float MAX_DENSITY = 250.0;

struct Particle {
    vec3 position;
    float density;
    vec3 velocity;
    float pressure;
};

layout(std430, binding = 0) restrict readonly buffer Particles {
    Particle particles[];
};

layout(std430, binding = 1) buffer Density {
    float densities[];
};

layout(std430, binding = 2) restrict readonly buffer Counts {
    uint counts[];
};

layout(std430, binding = 3) restrict readonly buffer Offsets {
    uint offsets[];
};

uniform float size;
uniform int sortRes;
uniform int res;

// neighborhood coordinate offsets
const ivec3 NEIGHBORHOOD[8] = {
    ivec3(0, 0, 0), ivec3(0, 0, -1),
    ivec3(0, -1, 0), ivec3(0, -1, -1), 
    ivec3(-1, 0, 0), ivec3(-1, 0, -1),
    ivec3(-1, -1, 0), ivec3(-1, -1, -1)
};

// optimize the number of bins searched by considering
// whether the bin's grid vertex belongs on the edge of the sorted bin.
// If it is not along an edge in a dimension, neighbors in that dimension can be skipped.
void getNeighboring(bool neighboring[8], vec3 binPos, vec3 sortBinPos) {
    bool xg = binPos.x > sortBinPos.x;
    bool yg = binPos.y > sortBinPos.y;
    bool zg = binPos.z > sortBinPos.z;
    if (xg) {
        neighboring[4] = false;
    }
    if (yg) {
        neighboring[2] = false;
    }
    if (zg) {
        neighboring[1] = false;
    }
    if (xg && yg) {
        neighboring[6] = false;
    }
    if (yg && zg) {
        neighboring[3] = false;
    }
    if (zg && zg) {
        neighboring[5] = false;
    }
    if (xg && yg && zg) {
        neighboring[7] = false;
    }
}

void main() {
    ivec3 coord = ivec3(gl_GlobalInvocationID);
    if (any(greaterThan(coord, uvec3(res)))) {
        return;
    }

    const float binSize = size / float(res);
    const float radius = binSize * 1.5;
    // bin position in world space
    const vec3 binPos = vec3(coord) * binSize;

    // compute corresponding sorted bin
    const float sortBinSize = size / float(sortRes);
    const ivec3 sortBinCoord = ivec3(floor(binPos / sortBinSize));
    // sort bin position in world space
    const vec3 sortBinPos = vec3(sortBinCoord) * sortBinSize;
    // optimize the number of bins searched by filtering
    // bool neighboring[8] = { true, true, true, true, true, true, true, true };
    // getNeighboring(neighboring, binPos, sortBinPos);

    float density = 0;
    int total = 0;

    // search neighboring bins
    #pragma unroll 1
    for (uint binIndex = 0; binIndex < 8; binIndex++) {
        // if (!neighboring[binIndex]) {
        //     continue;
        // }

        const ivec3 nc = sortBinCoord + NEIGHBORHOOD[binIndex];

        // don't go out of bounds
        if (any(lessThan(nc, ivec3(0))) || any(greaterThanEqual(nc, ivec3(sortRes)))) {
            continue;
        }

        const uint index = nc.z * sortRes * sortRes + nc.y * sortRes + nc.x;
        const uint count = counts[index];
        const uint offset = offsets[index];

        // search the particles of this bin
        for (uint localIndex = 0; localIndex < count; localIndex++) {
            const uint particleID = offset + localIndex;
            const Particle p = particles[particleID];
            const float dist = length(binPos - p.position);

            if (dist > radius) {
                continue;
            }

            total++;
            density += p.density;
        }
    }

    if (total > 0) {
        density /= total;
    }

    const uint index = coord.z * res * res + coord.y * res + coord.x;
    densities[index] = density / MAX_DENSITY;
}
